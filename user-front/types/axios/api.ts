/* tslint:disable */
/* eslint-disable */
/**
 * ECサイトuserAPIリファレンス
 * ECサイト上で買い物するユーザー画面のAPIリファレンスです
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

/**
 *
 * @export
 * @interface BookmarkItemRequest
 */
export interface BookmarkItemRequest {
  /**
   * ユーザーID
   * @type {string}
   * @memberof BookmarkItemRequest
   */
  userId: string
  /**
   * 商品ID
   * @type {string}
   * @memberof BookmarkItemRequest
   */
  itemId?: string
  /**
   * ブックマークの状態
   * @type {boolean}
   * @memberof BookmarkItemRequest
   */
  bookmarkFlg: boolean
}
/**
 *
 * @export
 * @interface BookmarkShopRequest
 */
export interface BookmarkShopRequest {
  /**
   * ショップID
   * @type {string}
   * @memberof BookmarkShopRequest
   */
  userId: string
  /**
   * ショップID
   * @type {string}
   * @memberof BookmarkShopRequest
   */
  shopId: string
  /**
   * ブックマーク状態
   * @type {boolean}
   * @memberof BookmarkShopRequest
   */
  bookmarkFlg: boolean
}
/**
 *
 * @export
 * @interface CreateUserAccountRequest
 */
export interface CreateUserAccountRequest {
  /**
   *
   * @type {string}
   * @memberof CreateUserAccountRequest
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof CreateUserAccountRequest
   */
  password: string
}
/**
 *
 * @export
 * @interface Error400
 */
export interface Error400 {
  /**
   * ステータスコード
   * @type {number}
   * @memberof Error400
   */
  status: number
  /**
   * リクエストメソッド
   * @type {string}
   * @memberof Error400
   */
  method: string
  /**
   * リクエストパス
   * @type {string}
   * @memberof Error400
   */
  path: string
  /**
   * エラーメッセージ
   * @type {object}
   * @memberof Error400
   */
  message: object
}
/**
 *
 * @export
 * @interface Error401
 */
export interface Error401 {
  /**
   * ステータスコード
   * @type {number}
   * @memberof Error401
   */
  status: number
  /**
   * リクエストメソッド
   * @type {string}
   * @memberof Error401
   */
  method: string
  /**
   * リクエストパス
   * @type {string}
   * @memberof Error401
   */
  path: string
  /**
   * エラーメッセージ
   * @type {object}
   * @memberof Error401
   */
  message: object
}
/**
 *
 * @export
 * @interface Error404
 */
export interface Error404 {
  /**
   * ステータスコード
   * @type {number}
   * @memberof Error404
   */
  status: number
  /**
   * リクエストメソッド
   * @type {string}
   * @memberof Error404
   */
  method: string
  /**
   * リクエストパス
   * @type {string}
   * @memberof Error404
   */
  path: string
  /**
   * エラーメッセージ
   * @type {object}
   * @memberof Error404
   */
  message: object
}
/**
 *
 * @export
 * @interface Error500
 */
export interface Error500 {
  /**
   * ステータスコード
   * @type {number}
   * @memberof Error500
   */
  status: number
  /**
   * リクエストメソッド
   * @type {string}
   * @memberof Error500
   */
  method: string
  /**
   * リクエストパス
   * @type {string}
   * @memberof Error500
   */
  path: string
  /**
   * エラーメッセージ
   * @type {object}
   * @memberof Error500
   */
  message: object
}
/**
 *
 * @export
 * @interface GetBookmarkedItemsRequest
 */
export interface GetBookmarkedItemsRequest {
  /**
   * ショップID
   * @type {string}
   * @memberof GetBookmarkedItemsRequest
   */
  userId: string
  /**
   * ショップID
   * @type {string}
   * @memberof GetBookmarkedItemsRequest
   */
  shopId: string
}
/**
 *
 * @export
 * @interface GetCsrfToken200Response
 */
export interface GetCsrfToken200Response {
  /**
   * CSRF Token
   * @type {string}
   * @memberof GetCsrfToken200Response
   */
  csrf_token?: string
}
/**
 *
 * @export
 * @interface Item
 */
export interface Item {
  /**
   * 商品ID
   * @type {string}
   * @memberof Item
   */
  id: string
  /**
   * 商品名
   * @type {string}
   * @memberof Item
   */
  name: string
  /**
   * 商品の画像URL
   * @type {string}
   * @memberof Item
   */
  image: string
  /**
   * 商品見出し
   * @type {string}
   * @memberof Item
   */
  caption?: string
  /**
   * 商品詳細
   * @type {string}
   * @memberof Item
   */
  description?: string
  /**
   * 価格
   * @type {number}
   * @memberof Item
   */
  price: number
  /**
   * 在庫数
   * @type {number}
   * @memberof Item
   */
  stocks: number
  /**
   * セール中かどうか
   * @type {boolean}
   * @memberof Item
   */
  onSale: boolean
  /**
   * 当日から到着までの日数
   * @type {number}
   * @memberof Item
   */
  deliveryDate: number
  /**
   * ブックマークしているか
   * @type {boolean}
   * @memberof Item
   */
  bookmarkFlg?: boolean
  /**
   * 商品追加日
   * @type {string}
   * @memberof Item
   */
  created_at?: string
  /**
   * 商品更新日
   * @type {string}
   * @memberof Item
   */
  updated_at?: string
}
/**
 *
 * @export
 * @interface Order
 */
export interface Order {
  /**
   * 購入ID（購入後に直ぐに購入履歴ページで詳細を確認するためにレスポンスとして返す）
   * @type {string}
   * @memberof Order
   */
  id: string
  /**
   * お届け先住所
   * @type {string}
   * @memberof Order
   */
  address: string
  /**
   * 購入日
   * @type {string}
   * @memberof Order
   */
  ordered_at: string
  /**
   * 購入した商品一覧
   * @type {Array<OrderOrderListInner>}
   * @memberof Order
   */
  orderList: Array<OrderOrderListInner>
}
/**
 *
 * @export
 * @interface OrderOrderListInner
 */
export interface OrderOrderListInner {
  /**
   * 商品ID
   * @type {string}
   * @memberof OrderOrderListInner
   */
  id?: string
  /**
   * 商品名
   * @type {string}
   * @memberof OrderOrderListInner
   */
  name?: string
  /**
   * 商品画像URL
   * @type {string}
   * @memberof OrderOrderListInner
   */
  image?: string
  /**
   * 商品見出し
   * @type {string}
   * @memberof OrderOrderListInner
   */
  caption?: string
  /**
   * 商品詳細
   * @type {string}
   * @memberof OrderOrderListInner
   */
  description?: string
  /**
   * 価格
   * @type {number}
   * @memberof OrderOrderListInner
   */
  price?: number
  /**
   * 購入した商品の個数
   * @type {number}
   * @memberof OrderOrderListInner
   */
  unit?: number
  /**
   * セール中かどうか
   * @type {boolean}
   * @memberof OrderOrderListInner
   */
  onSale?: boolean
  /**
   * お届け予定日
   * @type {string}
   * @memberof OrderOrderListInner
   */
  arrived_at?: string
}
/**
 *
 * @export
 * @interface Shop
 */
export interface Shop {
  /**
   * ショップID
   * @type {string}
   * @memberof Shop
   */
  id: string
  /**
   * ショップ名
   * @type {string}
   * @memberof Shop
   */
  name: string
  /**
   * ショップ画像
   * @type {string}
   * @memberof Shop
   */
  image: string
  /**
   * ショップの見出し
   * @type {string}
   * @memberof Shop
   */
  caption: string
  /**
   * ショップの詳細情報
   * @type {string}
   * @memberof Shop
   */
  description: string
  /**
   * ショップがブックマークされているか
   * @type {boolean}
   * @memberof Shop
   */
  bookmarkFlg?: boolean
  /**
   * ショップ追加日
   * @type {string}
   * @memberof Shop
   */
  created_at: string
  /**
   * ショップ更新日
   * @type {string}
   * @memberof Shop
   */
  updated_at: string
}
/**
 *
 * @export
 * @interface SignInRequest
 */
export interface SignInRequest {
  /**
   *
   * @type {string}
   * @memberof SignInRequest
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof SignInRequest
   */
  password: string
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  firstName: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastName: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  gender: UserGenderEnum
  /**
   *
   * @type {string}
   * @memberof User
   */
  tel: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  address: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  birthday: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  password: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  created_at: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  updated_at: string
}

export const UserGenderEnum = {
  Male: 'male',
  Female: 'female',
  Unknown: 'unknown',
} as const

export type UserGenderEnum = (typeof UserGenderEnum)[keyof typeof UserGenderEnum]

/**
 *
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  email: string
}

/**
 * BookmarkApi - axios parameter creator
 * @export
 */
export const BookmarkApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary 商品を欲しいものリストに追加
     * @param {BookmarkItemRequest} [bookmarkItemRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookmarkItem: async (
      bookmarkItemRequest?: BookmarkItemRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/bookmark/items`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(bookmarkItemRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ショップをお気に入りリストに追加
     * @param {BookmarkShopRequest} [bookmarkShopRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookmarkShop: async (
      bookmarkShopRequest?: BookmarkShopRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/bookmark/shops`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(bookmarkShopRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ブックマークしている商品一覧取得
     * @param {GetBookmarkedItemsRequest} [getBookmarkedItemsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBookmarkedItems: async (
      getBookmarkedItemsRequest?: GetBookmarkedItemsRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/bookmark/items`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(
        getBookmarkedItemsRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ブックマークしているショップ一覧取得
     * @param {string} userId ユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBookmarkedShops: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getBookmarkedShops', 'userId', userId)
      const localVarPath = `/user/bookmark/shops`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * BookmarkApi - functional programming interface
 * @export
 */
export const BookmarkApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BookmarkApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary 商品を欲しいものリストに追加
     * @param {BookmarkItemRequest} [bookmarkItemRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bookmarkItem(
      bookmarkItemRequest?: BookmarkItemRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bookmarkItem(bookmarkItemRequest, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['BookmarkApi.bookmarkItem']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @summary ショップをお気に入りリストに追加
     * @param {BookmarkShopRequest} [bookmarkShopRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bookmarkShop(
      bookmarkShopRequest?: BookmarkShopRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bookmarkShop(bookmarkShopRequest, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['BookmarkApi.bookmarkShop']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @summary ブックマークしている商品一覧取得
     * @param {GetBookmarkedItemsRequest} [getBookmarkedItemsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBookmarkedItems(
      getBookmarkedItemsRequest?: GetBookmarkedItemsRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmarkedItems(getBookmarkedItemsRequest, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['BookmarkApi.getBookmarkedItems']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @summary ブックマークしているショップ一覧取得
     * @param {string} userId ユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBookmarkedShops(
      userId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Shop>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmarkedShops(userId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['BookmarkApi.getBookmarkedShops']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * BookmarkApi - factory interface
 * @export
 */
export const BookmarkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = BookmarkApiFp(configuration)
  return {
    /**
     *
     * @summary 商品を欲しいものリストに追加
     * @param {BookmarkItemRequest} [bookmarkItemRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookmarkItem(bookmarkItemRequest?: BookmarkItemRequest, options?: any): AxiosPromise<string> {
      return localVarFp.bookmarkItem(bookmarkItemRequest, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ショップをお気に入りリストに追加
     * @param {BookmarkShopRequest} [bookmarkShopRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookmarkShop(bookmarkShopRequest?: BookmarkShopRequest, options?: any): AxiosPromise<string> {
      return localVarFp.bookmarkShop(bookmarkShopRequest, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ブックマークしている商品一覧取得
     * @param {GetBookmarkedItemsRequest} [getBookmarkedItemsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBookmarkedItems(
      getBookmarkedItemsRequest?: GetBookmarkedItemsRequest,
      options?: any
    ): AxiosPromise<Array<Item>> {
      return localVarFp
        .getBookmarkedItems(getBookmarkedItemsRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ブックマークしているショップ一覧取得
     * @param {string} userId ユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBookmarkedShops(userId: string, options?: any): AxiosPromise<Array<Shop>> {
      return localVarFp.getBookmarkedShops(userId, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * BookmarkApi - object-oriented interface
 * @export
 * @class BookmarkApi
 * @extends {BaseAPI}
 */
export class BookmarkApi extends BaseAPI {
  /**
   *
   * @summary 商品を欲しいものリストに追加
   * @param {BookmarkItemRequest} [bookmarkItemRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookmarkApi
   */
  public bookmarkItem(bookmarkItemRequest?: BookmarkItemRequest, options?: RawAxiosRequestConfig) {
    return BookmarkApiFp(this.configuration)
      .bookmarkItem(bookmarkItemRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ショップをお気に入りリストに追加
   * @param {BookmarkShopRequest} [bookmarkShopRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookmarkApi
   */
  public bookmarkShop(bookmarkShopRequest?: BookmarkShopRequest, options?: RawAxiosRequestConfig) {
    return BookmarkApiFp(this.configuration)
      .bookmarkShop(bookmarkShopRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ブックマークしている商品一覧取得
   * @param {GetBookmarkedItemsRequest} [getBookmarkedItemsRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookmarkApi
   */
  public getBookmarkedItems(getBookmarkedItemsRequest?: GetBookmarkedItemsRequest, options?: RawAxiosRequestConfig) {
    return BookmarkApiFp(this.configuration)
      .getBookmarkedItems(getBookmarkedItemsRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ブックマークしているショップ一覧取得
   * @param {string} userId ユーザーID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookmarkApi
   */
  public getBookmarkedShops(userId: string, options?: RawAxiosRequestConfig) {
    return BookmarkApiFp(this.configuration)
      .getBookmarkedShops(userId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary 商品詳細情報取得
     * @param {string} shopId 商品ID
     * @param {string} itemId 商品ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItemById: async (shopId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shopId' is not null or undefined
      assertParamExists('getItemById', 'shopId', shopId)
      // verify required parameter 'itemId' is not null or undefined
      assertParamExists('getItemById', 'itemId', itemId)
      const localVarPath = `/user/item/{itemId}`
        .replace(`{${'shopId'}}`, encodeURIComponent(String(shopId)))
        .replace(`{${'itemId'}}`, encodeURIComponent(String(itemId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary 商品一覧取得
     * @param {string} shopId ショップID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems: async (shopId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shopId' is not null or undefined
      assertParamExists('getItems', 'shopId', shopId)
      const localVarPath = `/user/item`.replace(`{${'shopId'}}`, encodeURIComponent(String(shopId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary 商品詳細情報取得
     * @param {string} shopId 商品ID
     * @param {string} itemId 商品ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getItemById(
      shopId: string,
      itemId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getItemById(shopId, itemId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['ItemApi.getItemById']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @summary 商品一覧取得
     * @param {string} shopId ショップID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getItems(
      shopId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getItems(shopId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['ItemApi.getItems']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ItemApiFp(configuration)
  return {
    /**
     *
     * @summary 商品詳細情報取得
     * @param {string} shopId 商品ID
     * @param {string} itemId 商品ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItemById(shopId: string, itemId: string, options?: any): AxiosPromise<Item> {
      return localVarFp.getItemById(shopId, itemId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary 商品一覧取得
     * @param {string} shopId ショップID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems(shopId: string, options?: any): AxiosPromise<Array<Item>> {
      return localVarFp.getItems(shopId, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
  /**
   *
   * @summary 商品詳細情報取得
   * @param {string} shopId 商品ID
   * @param {string} itemId 商品ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemApi
   */
  public getItemById(shopId: string, itemId: string, options?: RawAxiosRequestConfig) {
    return ItemApiFp(this.configuration)
      .getItemById(shopId, itemId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary 商品一覧取得
   * @param {string} shopId ショップID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemApi
   */
  public getItems(shopId: string, options?: RawAxiosRequestConfig) {
    return ItemApiFp(this.configuration)
      .getItems(shopId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary 注文履歴一覧取得
     * @param {string} userId ユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderHistory: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getOrderHistory', 'userId', userId)
      const localVarPath = `/user/order/history`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary 注文
     * @param {string} userId ユーザーID
     * @param {Array<string>} itemIds 商品ID
     * @param {string} address お届け先住所
     * @param {string} paymentMethod お支払い方法
     * @param {string} cardNumber カード番号
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    orderItem: async (
      userId: string,
      itemIds: Array<string>,
      address: string,
      paymentMethod: string,
      cardNumber: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('orderItem', 'userId', userId)
      // verify required parameter 'itemIds' is not null or undefined
      assertParamExists('orderItem', 'itemIds', itemIds)
      // verify required parameter 'address' is not null or undefined
      assertParamExists('orderItem', 'address', address)
      // verify required parameter 'paymentMethod' is not null or undefined
      assertParamExists('orderItem', 'paymentMethod', paymentMethod)
      // verify required parameter 'cardNumber' is not null or undefined
      assertParamExists('orderItem', 'cardNumber', cardNumber)
      const localVarPath = `/user/order`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId
      }

      if (itemIds) {
        localVarQueryParameter['itemIds'] = itemIds
      }

      if (address !== undefined) {
        localVarQueryParameter['address'] = address
      }

      if (paymentMethod !== undefined) {
        localVarQueryParameter['paymentMethod'] = paymentMethod
      }

      if (cardNumber !== undefined) {
        localVarQueryParameter['cardNumber'] = cardNumber
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary 注文履歴一覧取得
     * @param {string} userId ユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOrderHistory(
      userId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderHistory(userId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['OrderApi.getOrderHistory']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @summary 注文
     * @param {string} userId ユーザーID
     * @param {Array<string>} itemIds 商品ID
     * @param {string} address お届け先住所
     * @param {string} paymentMethod お支払い方法
     * @param {string} cardNumber カード番号
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async orderItem(
      userId: string,
      itemIds: Array<string>,
      address: string,
      paymentMethod: string,
      cardNumber: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.orderItem(
        userId,
        itemIds,
        address,
        paymentMethod,
        cardNumber,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['OrderApi.orderItem']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = OrderApiFp(configuration)
  return {
    /**
     *
     * @summary 注文履歴一覧取得
     * @param {string} userId ユーザーID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderHistory(userId: string, options?: any): AxiosPromise<Array<Order>> {
      return localVarFp.getOrderHistory(userId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary 注文
     * @param {string} userId ユーザーID
     * @param {Array<string>} itemIds 商品ID
     * @param {string} address お届け先住所
     * @param {string} paymentMethod お支払い方法
     * @param {string} cardNumber カード番号
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    orderItem(
      userId: string,
      itemIds: Array<string>,
      address: string,
      paymentMethod: string,
      cardNumber: string,
      options?: any
    ): AxiosPromise<Order> {
      return localVarFp
        .orderItem(userId, itemIds, address, paymentMethod, cardNumber, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
  /**
   *
   * @summary 注文履歴一覧取得
   * @param {string} userId ユーザーID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public getOrderHistory(userId: string, options?: RawAxiosRequestConfig) {
    return OrderApiFp(this.configuration)
      .getOrderHistory(userId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary 注文
   * @param {string} userId ユーザーID
   * @param {Array<string>} itemIds 商品ID
   * @param {string} address お届け先住所
   * @param {string} paymentMethod お支払い方法
   * @param {string} cardNumber カード番号
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public orderItem(
    userId: string,
    itemIds: Array<string>,
    address: string,
    paymentMethod: string,
    cardNumber: string,
    options?: RawAxiosRequestConfig
  ) {
    return OrderApiFp(this.configuration)
      .orderItem(userId, itemIds, address, paymentMethod, cardNumber, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ShopApi - axios parameter creator
 * @export
 */
export const ShopApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary ショップ詳細情報取得
     * @param {string} shopId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShopById: async (shopId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'shopId' is not null or undefined
      assertParamExists('getShopById', 'shopId', shopId)
      const localVarPath = `/user/shop/{shopId}`.replace(`{${'shopId'}}`, encodeURIComponent(String(shopId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ショップ一覧取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShops: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/user/shops`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ShopApi - functional programming interface
 * @export
 */
export const ShopApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ShopApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary ショップ詳細情報取得
     * @param {string} shopId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShopById(
      shopId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shop>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getShopById(shopId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['ShopApi.getShopById']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @summary ショップ一覧取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShops(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Shop>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getShops(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['ShopApi.getShops']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * ShopApi - factory interface
 * @export
 */
export const ShopApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ShopApiFp(configuration)
  return {
    /**
     *
     * @summary ショップ詳細情報取得
     * @param {string} shopId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShopById(shopId: string, options?: any): AxiosPromise<Shop> {
      return localVarFp.getShopById(shopId, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ショップ一覧取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShops(options?: any): AxiosPromise<Array<Shop>> {
      return localVarFp.getShops(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ShopApi - object-oriented interface
 * @export
 * @class ShopApi
 * @extends {BaseAPI}
 */
export class ShopApi extends BaseAPI {
  /**
   *
   * @summary ショップ詳細情報取得
   * @param {string} shopId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ShopApi
   */
  public getShopById(shopId: string, options?: RawAxiosRequestConfig) {
    return ShopApiFp(this.configuration)
      .getShopById(shopId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ショップ一覧取得
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ShopApi
   */
  public getShops(options?: RawAxiosRequestConfig) {
    return ShopApiFp(this.configuration)
      .getShops(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary 新規登録
     * @param {CreateUserAccountRequest} [createUserAccountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserAccount: async (
      createUserAccountRequest?: CreateUserAccountRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/signup`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createUserAccountRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary CSRFトークン取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCsrfToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/user/csrf`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ログイン
     * @param {SignInRequest} [signInRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signIn: async (signInRequest?: SignInRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/user/login`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(signInRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ログアウト
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signOut: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/user/logout`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary 新規登録
     * @param {CreateUserAccountRequest} [createUserAccountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserAccount(
      createUserAccountRequest?: CreateUserAccountRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAccount(createUserAccountRequest, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['UserApi.createUserAccount']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @summary CSRFトークン取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCsrfToken(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCsrfToken200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCsrfToken(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['UserApi.getCsrfToken']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @summary ログイン
     * @param {SignInRequest} [signInRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signIn(
      signInRequest?: SignInRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signIn(signInRequest, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['UserApi.signIn']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @summary ログアウト
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signOut(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signOut(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['UserApi.signOut']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UserApiFp(configuration)
  return {
    /**
     *
     * @summary 新規登録
     * @param {CreateUserAccountRequest} [createUserAccountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserAccount(createUserAccountRequest?: CreateUserAccountRequest, options?: any): AxiosPromise<UserResponse> {
      return localVarFp.createUserAccount(createUserAccountRequest, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary CSRFトークン取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCsrfToken(options?: any): AxiosPromise<GetCsrfToken200Response> {
      return localVarFp.getCsrfToken(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ログイン
     * @param {SignInRequest} [signInRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signIn(signInRequest?: SignInRequest, options?: any): AxiosPromise<void> {
      return localVarFp.signIn(signInRequest, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ログアウト
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signOut(options?: any): AxiosPromise<string> {
      return localVarFp.signOut(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @summary 新規登録
   * @param {CreateUserAccountRequest} [createUserAccountRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public createUserAccount(createUserAccountRequest?: CreateUserAccountRequest, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .createUserAccount(createUserAccountRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary CSRFトークン取得
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getCsrfToken(options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getCsrfToken(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ログイン
   * @param {SignInRequest} [signInRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public signIn(signInRequest?: SignInRequest, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .signIn(signInRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ログアウト
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public signOut(options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .signOut(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
